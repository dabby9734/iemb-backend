"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.handlePush = void 0;
const fs = require("fs");
const path = require("path");
const node_fetch_1 = require("node-fetch");
const perf_hooks_1 = require("perf_hooks");
const colorette_1 = require("colorette");
const crypto_1 = require("crypto");
const openapi_core_1 = require("@redocly/openapi-core");
const utils_1 = require("../utils");
const login_1 = require("./login");
function handlePush(argv) {
    return __awaiter(this, void 0, void 0, function* () {
        const region = argv.region || (yield openapi_core_1.loadConfig()).region;
        const client = new openapi_core_1.RedoclyClient(region);
        const isAuthorized = yield client.isAuthorizedWithRedoclyByRegion();
        if (!isAuthorized) {
            const clientToken = yield login_1.promptClientToken(client.domain);
            yield client.login(clientToken);
        }
        const startedAt = perf_hooks_1.performance.now();
        const { entrypoint, destination, branchName, upsert } = argv;
        if (!validateDestination(destination)) {
            utils_1.exitWithError(`Destination argument value is not valid, please use the right format: ${colorette_1.yellow('<@organization-id/api-name@api-version>')}`);
        }
        const [organizationId, name, version] = getDestinationProps(destination);
        try {
            let rootFilePath = '';
            const filePaths = [];
            const filesToUpload = yield collectFilesToUpload(entrypoint);
            const filesHash = hashFiles(filesToUpload.files);
            process.stdout.write(`Uploading ${filesToUpload.files.length} ${utils_1.pluralize('file', filesToUpload.files.length)}:\n`);
            let uploaded = 0;
            for (let file of filesToUpload.files) {
                const { signedUploadUrl, filePath } = yield client.registryApi.prepareFileUpload({
                    organizationId,
                    name,
                    version,
                    filesHash,
                    filename: file.keyOnS3,
                    isUpsert: upsert,
                });
                if (file.filePath === filesToUpload.root) {
                    rootFilePath = filePath;
                }
                filePaths.push(filePath);
                process.stdout.write(`Uploading ${file.contents ? 'bundle for ' : ''}${colorette_1.blue(file.filePath)}...`);
                const uploadResponse = yield uploadFileToS3(signedUploadUrl, file.contents || file.filePath);
                const fileCounter = `(${++uploaded}/${filesToUpload.files.length})`;
                if (!uploadResponse.ok) {
                    utils_1.exitWithError(`✗ ${fileCounter}\nFile upload failed\n`);
                }
                process.stdout.write(colorette_1.green(`✓ ${fileCounter}\n`));
            }
            process.stdout.write('\n');
            yield client.registryApi.pushApi({
                organizationId,
                name,
                version,
                rootFilePath,
                filePaths,
                branch: branchName,
                isUpsert: upsert,
            });
        }
        catch (error) {
            if (error.message === 'ORGANIZATION_NOT_FOUND') {
                utils_1.exitWithError(`Organization ${colorette_1.blue(organizationId)} not found`);
            }
            if (error.message === 'API_VERSION_NOT_FOUND') {
                utils_1.exitWithError(`The definition version ${colorette_1.blue(name)}/${colorette_1.blue(version)} does not exist in organization ${colorette_1.blue(organizationId)}!\n${colorette_1.yellow('Suggestion:')} please use ${colorette_1.blue('-u')} or ${colorette_1.blue('--upsert')} to create definition.
    `);
            }
            throw error;
        }
        process.stdout.write(`Definition: ${colorette_1.blue(entrypoint)} is successfully pushed to Redocly API Registry \n`);
        utils_1.printExecutionTime('push', startedAt, entrypoint);
    });
}
exports.handlePush = handlePush;
function getFilesList(dir, files) {
    files = files || [];
    const filesAndDirs = fs.readdirSync(dir);
    for (const name of filesAndDirs) {
        if (fs.statSync(path.join(dir, name)).isDirectory()) {
            files = getFilesList(path.join(dir, name), files);
        }
        else {
            const currentPath = dir + '/' + name;
            files.push(currentPath);
        }
    }
    return files;
}
function collectFilesToUpload(entrypoint) {
    return __awaiter(this, void 0, void 0, function* () {
        let files = [];
        const config = yield openapi_core_1.loadConfig();
        const entrypoints = yield utils_1.getFallbackEntryPointsOrExit([entrypoint], config);
        const entrypointPath = entrypoints[0];
        process.stdout.write('Bundling definition\n');
        const { bundle: openapiBundle, problems } = yield openapi_core_1.bundle({
            config,
            ref: entrypointPath,
            skipRedoclyRegistryRefs: true,
        });
        const fileTotals = openapi_core_1.getTotals(problems);
        if (fileTotals.errors === 0) {
            process.stdout.write(`Created a bundle for ${colorette_1.blue(entrypoint)} ${fileTotals.warnings > 0 ? 'with warnings' : ''}\n`);
        }
        else {
            utils_1.exitWithError(`Failed to create a bundle for ${colorette_1.blue(entrypoint)}\n`);
        }
        const fileExt = path.extname(entrypointPath).split('.').pop();
        files.push(getFileEntry(entrypointPath, utils_1.dumpBundle(openapiBundle.parsed, fileExt)));
        if (fs.existsSync('package.json')) {
            files.push(getFileEntry('package.json'));
        }
        if (fs.existsSync(openapi_core_1.IGNORE_FILE)) {
            files.push(getFileEntry(openapi_core_1.IGNORE_FILE));
        }
        if (config.configFile) {
            files.push(getFileEntry(config.configFile));
            if (config.referenceDocs.htmlTemplate) {
                const dir = getFolder(config.referenceDocs.htmlTemplate);
                const fileList = getFilesList(dir, []);
                files.push(...fileList.map((f) => getFileEntry(f)));
            }
            if (config.rawConfig && config.rawConfig.lint && config.rawConfig.lint.plugins) {
                let pluginFiles = new Set();
                for (const plugin of config.rawConfig.lint.plugins) {
                    if (typeof plugin !== 'string')
                        continue;
                    const fileList = getFilesList(getFolder(plugin), []);
                    fileList.forEach((f) => pluginFiles.add(f));
                }
                files.push(...filterPluginFilesByExt(Array.from(pluginFiles)).map((f) => getFileEntry(f)));
            }
        }
        return {
            files,
            root: path.resolve(entrypointPath),
        };
        function filterPluginFilesByExt(files) {
            return files.filter((file) => {
                const fileExt = path.extname(file).toLowerCase();
                return fileExt === '.js' || fileExt === '.ts' || fileExt === '.mjs' || fileExt === 'json';
            });
        }
        function getFileEntry(filename, contents) {
            return {
                filePath: path.resolve(filename),
                keyOnS3: config.configFile
                    ? openapi_core_1.slash(path.relative(path.dirname(config.configFile), filename))
                    : openapi_core_1.slash(path.basename(filename)),
                contents: (contents && Buffer.from(contents, 'utf-8')) || undefined,
            };
        }
    });
}
function getFolder(filePath) {
    return path.resolve(path.dirname(filePath));
}
function hashFiles(filePaths) {
    let sum = crypto_1.createHash('sha256');
    filePaths.forEach((file) => sum.update(fs.readFileSync(file.filePath)));
    return sum.digest('hex');
}
function validateDestination(destination) {
    const regexp = /^@+[a-zA-Z0-9-_.& ]+\/+[^@\/]+@[^@\/]+$/g;
    return regexp.test(destination);
}
function getDestinationProps(destination) {
    return destination.substring(1).split(/[@\/]/);
}
function uploadFileToS3(url, filePathOrBuffer) {
    const fileSizeInBytes = typeof filePathOrBuffer === 'string'
        ? fs.statSync(filePathOrBuffer).size
        : filePathOrBuffer.byteLength;
    let readStream = typeof filePathOrBuffer === 'string' ? fs.createReadStream(filePathOrBuffer) : filePathOrBuffer;
    return node_fetch_1.default(url, {
        method: 'PUT',
        headers: {
            'Content-Length': fileSizeInBytes.toString(),
        },
        body: readStream,
    });
}
